Представьте себе ситуацию. Вы работаете над какой-то важной задачей и
исправили довольно много файлов. В этот момент появляется срочная задача —
сделать какое-то изменение в исходном коде, не связанное с тем, над чем вы сейчас
работаете. Ваши изменения ещё не готовы и они не должны попасть в репозиторий.
Что делать?

В самом простом случае, если ваши изменения не пересекаются с изменениями по
срочной задаче, вы можете внести исправления, добавить их в индекс, закоммитить и
запушить. Но обычно это неудобно и не всегда возможно. А если изменения нужно делать в
тех файлах, с которыми вы работаете прямо сейчас?

Подобная ситуация у опытных разработчиков встречается регулярно и, к счастью,
она легко решается. В git существует набор команд, позволяющий «прятать» изменения в
рабочей директории и восстанавливать их при необходимости.
Попробуем:

Создадим новый файл в нашем проекте:

> echo 'new file lorem ipsum' > new-file.md

> git add new-file.md  // добавим наш файл

> git status // проверим все ли нормально

Вывод:

On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	new file:   new-file.md

Выполним команду git stash и git status

> git stash
вывод: Saved working directory and index state WIP on master: 03a8e24 added .gitignore

> git status
видим что git status не показывает нам файлы, как будто нечего комитить, все правильно
мы спрятали файлы которые от не хотим добавлять в текущий коммит и можем вернуться
к ним позже, после выполнения срочной задачи

См. картинку ../images/git_stash.jpg


------ Прошло немного времени и вы хотим вернуть все то что спрятали -----

Для этого мы выполним команду  git stash pop

> git stash pop

Вывод:
Changes to be committed:
 (use "git restore --staged <file>..." to unstage)
new file:   new-file.md

Dropped refs/stash@{0} (a162e61b57ef199d36e9abe157b8e9a804d46208)

Видим что все файлы которые мы спрятали, вернулись обратно.

Stash в Git работает по принципу стека. Он позволяет
сохранить внутрь любое количество изменений и восстановить
их в обратном порядке:

Пример:

> git stash

# изменяем файлы
> git stash

# Вернутся последние изменения
> git stash pop

# Вернутся предпоследние изменения
> git stash pop